load("@hedron_compile_commands//:refresh_compile_commands.bzl", "refresh_compile_commands")
refresh_compile_commands(
    name = "refresh_compile_commands",
    targets = {
        "//src:main": "", # empty string means "no additional flags"
    },
)

##################
# Usage example: #
##################

# Specify the targets of interest.
    # This will create compile commands entries for all the code compiled by those targets, including transitive dependencies.
        # If you're working on a header-only library, specify a test or binary target that compiles it.
# If you're doing this manually, you usually want to just specify the top-level output targets you care about.
    # This avoids issues where some targets can't be built on their own; they need configuration by a parent rule. android_binaries using transitions to configure android_libraries are an example.
# The targets parameter is forgiving in its inputs.
    # You can specify just one target:
        # targets = "//:my_output_binary_target",
    # Or a list of targets:
        # targets = ["//:my_output_1", "//:my_output_2"],
    # Or a dict of targets and any flags required to build:
        # (No need to add flags already in .bazelrc. They're automatically picked up.)
        # targets = {
        #   "//:my_output_1": "--important_flag1 --important_flag2=true",
        #   "//:my_output_2": "",
        # },
    # If you don't specify a target, that's fine (if it works for you); compile_commands.json will default to containing commands used in building all possible targets. But in that case, just bazel run @hedron_compile_commands//:refresh_all
    # Wildcard target patterns (..., *, :all) patterns *are* allowed, like in bazel build
        # For more, see https://docs.bazel.build/versions/main/guide.html#specifying-targets-to-build
    # As are additional targets (+) and subtractions (-), like in bazel query https://docs.bazel.build/versions/main/query.html#expressions
# Using ccls or another tool that doesn't want or need headers in compile_commands.json?
    # exclude_headers = "all", # By default, we include entries for headers to support clangd, working around https://github.com/clangd/clangd/issues/123
    # ^ excluding headers will speed up compile_commands.json generation *considerably* because we won't need to preprocess your code to figure out which headers you use.
    # However, if you use clangd and are looking for speed, we strongly recommend you follow the instructions below instead, since clangd is going to regularly infer the wrong commands for headers and give you lots of annoyingly unnecessary red squigglies.
# Need things to run faster? [Either for compile_commands.json generation or clangd indexing.]
# First: You might be able to refresh compile_commands.json slightly less often, making the current runtime okay.
    # If you're adding files, clangd should make pretty decent guesses at completions, using commands from nearby files. And if you're deleting files, there's not a problem. So you may not need to rerun refresh.py on every change to BUILD files. Instead, maybe refresh becomes something you run every so often when you can spare the time, making the current runtime okay.
    # If that's not enough, read on.
# If you don't care about the implementations of external dependencies:
    # Then skip adding entries for compilation in external workspaces with
    # exclude_external_sources = True,
    # ^ Defaults to False, so the broadest set of features are supported out of the box, without prematurely optimizing.
# If you don't care about browsing headers from external workspaces or system headers, except for a CTRL/CMD+click every now and then:
    # Then no need to add entries for their headers, because clangd will correctly infer from the CTRL/CMD+click (but not a quick open or reopen).
    # exclude_headers = "external",
# Still not fast enough?
    # Make sure you're specifying just the targets you care about by setting `targets`, above.
